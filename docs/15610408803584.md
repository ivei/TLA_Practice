# ç¬¬7ç«  ç®—æ³•éªŒè¯

è¿™ä¸€ç« ä¼šè®²è¿°å¦‚ä½•ç”¨TLA+ç¼–å†™å’ŒéªŒè¯ç®—æ³•ã€‚
æ‰€è°“éªŒè¯ç®—æ³•ï¼ŒæŒ‡çš„æ˜¯ç®—æ³•ä¼šç»ˆæ­¢ä¸”è¾“å‡ºç»“æœï¼Œè€Œä¸æ˜¯ä¸€ç›´è·‘ä¸‹å»æˆ–ä¸æ–­ä¸ç¯å¢ƒäº¤äº’

## 7.1 å•è¿‡ç¨‹ï¼ˆSingle-Processï¼‰ç®—æ³•
æ¨¡æ¿ï¼š

```
---- MODULE name ---- 
EXTENDS \* whatever 

Expected(input) == \* ...

Helpers == \* ...

(*--algorithm name 
variables   
    input \in \* ...
    output; \* ...
    \* helper variables
    
begin   
    \* algorithm implementation   
        assert output = Expected(input); 
end algorithm; *) 
====
```
å†…å®¹ï¼š
* Expected
* Helpers
* inputs
* output

## 7.2 Max
### 7.2.1 ç®—æ³•åˆ†æè®¾è®¡
è®¡ç®—ä¸€ä¸ª`sequence`çš„æœ€å¤§å€¼ã€‚ä¾‹å¦‚ï¼š`max(<<1, 1, 2, -1>>) = 2`

é¦–å…ˆå®šä¹‰operatorï¼š`CHOOSE x \in set: \A y \in set: y <= x`

å› æ­¤

```
ExTENDS Sequences 

Max(seq) ==   
    LET set == { seq[i]: i \in 1..Len(seq)}   
    IN CHOOSE x \in set: \A y \in set: y <= x
```
è¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–æ•ˆç‡ï¼š

```
Max(seq) ==   
    LET index ==     
        CHOOSE x \in 1..Len(seq):       
            \A y \in 1..Len(seq): seq[y] <= seq[x]   
    IN seq[index]
```
> è¿™ä¸ªæ‰€è°“çš„æå‡å¥½åƒæ˜¯æŠŠindexç»™ä¼˜åŒ–äº†ï¼Ÿ

æœ€ç»ˆå½¢æˆçš„ç®—æ³•å°±æ˜¯ï¼š

```
EXTENDS Integers, Sequences, TLC 
CONSTANTS IntSet, MaxSeqLen 
ASSUME IntSet \subseteq Int 
ASSUME MaxSeqLen > 0 

PT == INSTANCE PT

Max(seq) ==   
    LET set == {seq[i]: i \in 1..Len(seq)}   
    IN CHOOSE x \in set: \A y \in set: y <= x 

AllInputs == PT!SeqOf(IntSet, MaxSeqLen) 

(*â€”algorithm max 
variables seq \in AllInputs, i = 1, max; 
begin   
    max := seq[1];   
    while i <= Len(seq) do     
        if max < seq[i] then       
            max := seq[i];     
        end if;     
        i := i + 1;   
   end while;   
   assert max = Max(seq); 
end algorithm; *)
```
> å¤–é¢çš„`Max`æ˜¯ç”¨äºæ£€æŸ¥ç®—æ³•æ­£ç¡®æ€§çš„ï¼‚æ ‡å‡†ï¼‚ï¼Œè€Œ`algorithm`ä¸­æ‰æ˜¯æˆ‘ä»¬è¦æ£€æŸ¥æ­£ç¡®æ€§çš„ï¼‚ç®—æ³•ï¼‚ï¼å·®ç‚¹å–§å®¾å¤ºä¸»äº†


### 7.2.2 æ„é€ è¾“å…¥æ•°æ®æµ‹è¯•

åœ¨ToolBoxä¸­è®¾ç½®ï¼š

```
defaultInitValue <- [ model value ] 
IntSet <- -5..5 
MaxSeqLen <- 5
```
æ‰§è¡Œå¤±è´¥ã€‚é”™è¯¯ä¿¡æ¯æ˜¾ç¤ºè¯•å›¾è®¡ç®—`<<>>[1]`ã€‚
ä¿®æ”¹ï¼š

```
â—ï¸åœ¨AllInputä¸­å»æ‰ç©ºé›†
AllInputs == PT!SeqOf(IntSet, MaxSeqLen) \ {<<>>}
(*--algorithm max 
variables seq \in AllInputs, i = 1, max;
begin   
â—ï¸å¢åŠ assertæ–­è¨€
    assert Len(seq) > 0;   
    max := seq[1];
```
> ä¹¦ä¸Šè¯´ï¼Œè¿™ä¸ªè¾“å…¥ä¸‹çš„çŠ¶æ€æœ‰1,576,685ä¸ªğŸ˜±
> çš„ç¡®è¿™ä¸ªæ•°é‡å¾ˆæƒŠäºº
> å› æ­¤ï¼Œæˆ‘è§‰çš„ï¼Œæˆ‘ä»¬åœ¨å¯¹ç®—æ³•éªŒè¯æ—¶å¿…é¡»è¦å¯¹è¾“å…¥åšç®€åŒ–å’ŒæŠ½è±¡ã€‚åŒæ—¶ï¼Œæˆ‘è®¤ä¸ºä¼å›¾é»‘ç›’æ–¹å¼æè‡ªåŠ¨åŒ–çš„å½¢å¼åŒ–éªŒè¯ä¹Ÿæ˜¯æœ‰é—®é¢˜çš„ã€‚å‚»ç“œå¼çš„å·¥å…·ä¸èƒ½ä»£æ›¿äººçš„æŠ½è±¡æ€ç»´èƒ½åŠ›


## 7.3 Laft pad
LeftpadæŒ‡çš„æ˜¯æ ¹æ®é•¿åº¦å¡«å……å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ï¼š
`Leftpad(â€ â€œ, 5, â€fooâ€œ) = â€ fooâ€œ`ï¼Œè€Œ`Leftpad(â€ â€œ, 1, â€fooâ€œ) = â€fooâ€œ`

### 7.3.1 å»ºæ¨¡
ç”¨å­—ç¬¦ä¸²åºåˆ—æ¥ä»£æ›¿å­—ç¬¦ä¸²ï¼Œå› ä¸ºå®ƒåœ¨TLA+ä¸­æ“ä½œèµ·æ¥æ›´æ–¹ä¾¿
`Leftpad(c, n, str)`ï¼Œå…¶å®Œæ•´çš„è§„æ ¼ï¼š
1. `Len(Leftpad(c, n, str)) = Max(n, Len(str))`
2. è¾“å‡ºçš„åé¢éƒ¨åˆ†ä¸º`str`
3. åœ¨`str`ä¹‹å‰çš„å­—ç¬¦(è‹¥æœ‰)ä¸º`c`

å³è§„æ ¼å¦‚ä¸‹ï¼š

```
Leftpad(c, n, str) ==   
    LET     
        outlength == PT!Max(Len(str), n)     
        padlength ==       
            CHOOSE padlength \in 0..n:         
                padlength + Len(str) = outlength   
      IN     
          [x \in 1..padlength |-> c] \o str
```
> `\o`æ˜¯`combine`è¿ç®—
> TLAä¸­çš„æè¿°æ€§è§„æ ¼å¾ˆæ€ªå¼‚

ä¸ºäº†å‡å°‘æ— è°“çš„çŠ¶æ€ç©ºé—´çš„å¤§å°ï¼Œæˆ‘ä»¬ä»…é€‰æ‹©æœ‰é™çš„å­—ç¬¦é›†è¿›è¡Œæµ‹è¯•ã€‚

```
Characters == {"a", "b", "c"} 

(*--algorithm leftpad 
variables   
    in_c \in Characters \union {â€ â€œ},   
    in_n \in 0..6,   
    in_str \in PT!SeqOf(Characters, 6),   
    output; 

begin   
    output := in_str;   
    while Len(output) < in_n do     
        output := <<in_c>> \o output;
    end while;   
    assert output = Leftpad(in_c, in_n, in_str); 
end algorithm; *)
```
> è¿™é‡Œï¼Œè¿™ä¸ªç®—æ³•çš„å®ç°å…¶å®æŒºç¬¨çš„ ğŸ˜…
> >  `in_c`æ˜¯è¦ç”¨æ¥å¡«å……çš„å­—ç¬¦
> >  `in_n`æ˜¯é•¿åº¦
> >  `in_str`æ˜¯è¾“å…¥å­—ç¬¦ä¸²ï¼Œ`PT!SeqOf`è¿™ä¸ªå‡½æ•°

ä»…ä»…ä¸‰ä¸ªå­—ç¬¦å°±æ€»å…±æœ‰125ï¼Œ632ç§çŠ¶æ€ï¼

è¯•ä¸€ä¸‹å¦‚æœç®—æ³•å†™é”™äº†ã€‚æŠŠ`Len(output) < in_n`æ”¹ä¸º`Len(output) <= in_n`ï¼Ÿ

å¦å¤–ä¸€ä¸ªä¸å¸¸è§çš„é”™è¯¯æƒ…å†µæ˜¯æŠŠ`in_n \in 0..6`å†™æˆäº†`in_n \in -1..6`ã€‚å› ä¸º0..-1æ˜¯ç©ºé›†ï¼Œ`padlength`çš„å€¼æ˜¯æœªå®šä¹‰çš„ã€‚è¿™å¯èƒ½æ˜¯å› ä¸ºæˆ‘ä»¬ç»™å‡ºçš„å®šä¹‰æ˜¯é”™çš„ï¼Œå› ä¸ºè´Ÿæ•°ä¸ªæ•°çš„padå®šä¹‰æ˜¯æ— æ„ä¹‰çš„ï¼Œä¹Ÿå¯èƒ½è§„æ ¼å°±æ˜¯é”™è¯¯çš„ã€‚Leftpadå¡«å……çš„å­—ç¬¦çš„ä¸ªæ•°ä¸åº”æ˜¯è´Ÿçš„ã€‚

æ¯”å¦‚ï¼Œæˆ‘ä»¬è§„å®šè‹¥`n`æ˜¯è´Ÿæ•°å°±ä¸åšä»»ä½•å¡«å……ï¼š

```
Leftpad(c, n, str) ==   
    âœğŸ»ä¿®æ”¹è¿™é‡Œ
    IF n < 0 THEN str ELSE   
    LET     
        outlength == PT!Max(Len(str), n)     
        padlength ==       
            CHOOSE padlength \in 0..n:         
                padlength + Len(str) = outlength   
    IN     
        [x \in 1..padlength |-> c] \o str
```

è‹¥`Leftpad`æ”¯æŒ`n`ä¸ºè´Ÿæ•°ï¼Œé‚£å°±æ˜¯æˆ‘ä»¬çš„è§„æ ¼æ˜¯é”™çš„ï¼Œæˆ‘ä»¬è¦åŠ ä¸Šæ£€æŸ¥ï¼š

```
(*--algorithm leftpad 
variables   
    in_c \in Characters \union {â€ â€œ},   
    in_n \in 0..6,   
    in_str \in PT!SeqOf(Characters, 6),   
    output; 
begin   
    assert in_n >= 0;   
    output := in_str;   
    while Len(output) < in_n do     
        output := <<in_c>> \o output;
    end while;   
    
    assert output = Leftpad(in_c, in_n, in_str); 
end algorithm; *)
```

## 7.4 ç®—æ³•çš„å±æ€§

éªŒè¯ç®—æ³•çš„æ­£ç¡®æ€§å¾ˆå®¹æ˜“ï¼Œè€Œè¦éªŒè¯æ€§èƒ½ç­‰å°±å›°éš¾äº†ã€‚
å¯ä»¥åŠ ä¸€äº›è¾…åŠ©å˜é‡å¹¶åœ¨è®¡ç®—ç»“æŸåæ£€æŸ¥ã€‚

è€ƒè™‘äºŒåˆ†æ³•ç®—æ³•ï¼Œè¦éªŒè¯å®ƒçš„å¤æ‚åº¦æ˜¯$log_2(n)$ã€‚

å…ˆå†™ä¸€ä¸ªï¼ˆæ‰€è°“çš„ï¼‰â€œbinary searchâ€ï¼Œç”±äºäºŒåˆ†æ³•æ˜¯å¯¹æ’åºçš„åºåˆ—è¿›è¡Œæœç´¢ï¼Œæˆ‘ä»¬ç”¨`PT!SeqOf`ç”Ÿæˆåºåˆ—å¹¶è¿‡æ»¤æ‰æ— åºçš„
> è¿™æ‰æ˜¯æˆ‘çœŸæ­£åº”å­¦ä¹ çš„ä¸œè¥¿
> ä½†ï¼Œè¿™ä¸ªæ€§èƒ½è¯¥æœ‰å¤šå·®å•Šï¼ğŸ˜“

```
OrderedSeqOf(set, n) ==   
    {  seq \in PT!SeqOf(set, n):     
            \A x \in 2..Len(seq):       
                seq[x] >= seq[x-1] }
      
MaxInt == 4 
Range(f) == {f[x]: x \in DOMAIN f} 
 
(*â€”algorithm definitely_binary_search 
variables 
    i = 1,           
    seq \in OrderedSeqOf(1..MaxInt, MaxInt),
    target \in 1..MaxInt,
    found_index = 0; 
begin
    Search:
        while i <= Len(seq) do
            if seq[i] = target then
                found_index := i;
                goto Result;
            else
                i := i + 1;
            end if;
        end while;
    Result:
        if target \in Range(seq) then
           assert seq[found_index] = target;
        else
            \* 0 is out of DOMAIN seq, so can represent â€not foundâ€œ       
            assert found_index = 0;
        end if; 
end algorithm; *)
```
> è¿™ä¸ªå½“ç„¶ä¸æ˜¯äºŒåˆ†æ³•ï¼

æ¥ä¸‹æ¥è¦æ£€æŸ¥å¤æ‚åº¦ã€‚
ç”¨`while `å¾ªç¯çš„æ¬¡æ•°ä½œä¸ºç²—ç•¥çš„æœç´¢æ¬¡æ•°ï¼Œå› ä¸ºTLAä¸æ”¯æŒæµ®ç‚¹æ•°ï¼Œæ‰€ä»¥ç”¨å…¶åå‡½æ•°ï¼š`Pow2`ï¼š

```
Pow2(n) ==   
    LET f[x \in 0..n] ==     
        IF x = 0     
            THEN 1     
       ELSE 2*f[x-1]   
    IN f[n]
```
è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥æ–­è¨€ï¼š`Pow2(counter-1) <= Len(seq)`


```
variables 
    i = 1,
    seq \in OrderedSeqOf(1..MaxInt, MaxInt),
    target \in 1..MaxInt,
    found_index = 0,
    counter = 0; ğŸ”†æ–°å¢çš„æ¬¡æ•°è®¡æ•°å™¨
Search: 
    while i <= Len(seq) do
        counter := counter + 1;   ğŸ”†
        if seq[i] = target then
            found_index := m;
            goto Result;
        end if;
        i := i + 1   
    end while; 
Result:   
    âš ï¸åœ¨è¿™é‡Œå¢åŠ æ£€æŸ¥
    if Len(seq) > 0 then     
        assert Pow2(counter-1) <= Len(seq);   
    end if;   
    if target \in PT!Range(seq) then     
        assert seq[found_index] = target;   
   else     
       assert found_index = 0;   
  end if;
```
ä¸‹é¢æ‰æ˜¯çœŸæ­£çš„äºŒåˆ†æ³•ï¼š

```
(*--algorithm binary_search 
variables 
    low = 1,           
    seq \in OrderedSeqOf(1..MaxInt, MaxInt),
    high = Len(seq),
    target \in 1..MaxInt,
    found_index = 0,
    counter = 0; 
    
begin 
Search:
    while low <= high do
        counter := counter + 1; 
        with
            m = (high + low) \div 2 
            do
                if seq[m] = target then
                    found_index := m;
                    goto Result;
                elsif seq[m] < target then
                   low := m + 1;
                else
                    high := m - 1;
                end if;
           end with;
      end while;
Result:
    if Len(seq) > 0 then
         assert Pow2(counter-1) <= Len(seq);
    end if;
    if target \in Range(seq) then
        assert seq[found_index] = target;
    else
        assert found_index = 0;
    end if; 
end algorithm; *)
```

ä¸Šé¢ä¾‹å­ä¸­æœ‰ä¸€ä¸ªå¾®å¦™çš„é”™è¯¯ï¼š`low + high`å¯èƒ½ä¼šè¶…è¿‡æœºå™¨ä¸Šçš„æ•´æ•°çš„èŒƒå›´ã€‚ä¸‹é¢æ£€æŸ¥äº†ï¼š


![](media/15610408803584/15612128806027.jpg)
è¿™æ ·ä¼šå¤±è´¥ã€‚å¯ä»¥æ”¹æˆï¼š

![](media/15610408803584/15612129690457.jpg)

ç»™ä¸€ä¸ªä¸“é—¨ç”¨äºæ£€æŸ¥æº¢å‡ºçš„ä¸å˜é‡ï¼š

```
NoOverflows ==   
    \A x \in {m, lh, low, high}:     
        x <= MaxInt
```

## 7.5 å¤šå¤„ç†å™¨ç®—æ³•ï¼ˆè¿˜æ˜¯å¤šè¿›ç¨‹ç®—æ³•ï¼Ÿï¼‰

åœ¨æ‰€æœ‰çš„è¿›ç¨‹ç»“æŸæ—¶æ£€æŸ¥æ–­è¨€
ä½¿ç”¨â€œeventually alwaysâ€ (<>[]) operatoræ¥æ£€æŸ¥
è‹¥ä¸æƒ³æ¨¡æ‹Ÿç®—æ³•ä¸­é€”å´©æºƒçš„æƒ…å†µï¼Œåˆ™ä½¿ç”¨`fair`

```
EXTENDS Integers, Sequences, TLC 

(*--algorithm counter_incrementer 
variables   
    counter = 0,
    goal = 3;
    
define   
    Success == <>[](counter = goal)
end define; 

fair process incrementer \in 1..3 
variable 
    local = 0 
begin   
    Get:     
        local := counter;
    Increment:     
        counter := local + 1; 
end process; 

end algorithm; *)
```
This, unsurprisingly, fails, as our processes can increment based off stale memory. 
If we merge the two labels into one label, this succeeds with 22 states.
