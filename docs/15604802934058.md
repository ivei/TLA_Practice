# ç¬¬3ç«  Operatorå’ŒFunction

> å®ƒçš„å«æ³•å¾ˆåˆ«æ‰­ï¼ŒOperatorä»¥åå«ï¼‚ç®—å­ï¼‚ï¼ŒFunction è¿˜å«ï¼‚å‡½æ•°ï¼‚ã€‚çœŸéš¾å—ï¼


## 3.1 Operator

æœ‰äº›ç±»ä¼¼äºä¸€èˆ¬ç¼–ç¨‹è¯­è¨€ä¸­çš„å‡½æ•°/è¿‡ç¨‹ã€‚
æ— å‚æ•°æ—¶ä¸ç”¨å†™
ç”¨`==`å®šä¹‰ï¼š
* `Op(arg1, arg2) == Expr`
* `Op == Expr`


> å®ƒå¯ä»¥å½“å®ç”¨ï¼Œä¹Ÿå¯ä»¥å½“å˜é‡ç”¨

åƒåœ¾æ¡¶ä¾‹å­ä¸­çš„æ”¹è¿›ï¼š

![](media/15604802934058/15604822481555.jpg)

è‹¥è¦åœ¨ç®—å­ä¸­ç”¨PlusCalç®—æ³•ä¸­å®šä¹‰çš„å˜é‡ï¼Œåˆ™è¦æŠŠå®ƒæ”¾åœ¨`define`å—ä¸­ï¼šå¿…é¡»åœ¨å®å®šä¹‰ä¹‹å‰ï¼Œå˜é‡å®šä¹‰ä¹‹åã€‚


![](media/15604802934058/15604824761772.jpg)

####  /\çš„ç‰¹åˆ«çš„ç”¨æ³•

ä¸ºäº†ç¾è§‚ï¼Œç¬¬ä¸€ä¸ªå‰é¢ä¹Ÿå¯ä»¥æ”¾ä¸€ä¸ª`/\`æˆ–`\/`è¿™ç§ï¼š
![](media/15604802934058/15604827405477.jpg)

ç¼©è¿›è¡¨ç¤ºåµŒå¥—æ‹¬å·ï¼š

![](media/15604802934058/15604828754951.jpg)

#### ç®—å­ä¸­æ”¯æŒLambdaå’Œé«˜é˜¶å‡½æ•°

LAMBDAå’Œé«˜é˜¶å‡½æ•°
```
Add(a, b) == a + b 
Apply(op(_, _), x, y) == op(x, y) 

>> Apply(Add, 1, 2) 
>> 3

Apply(LAMBDA x, y: x + y, 1, 2) >> 3

```


#### é›†åˆ++å’Œâ€”


```
set ++ elem == set \union {elem} 

set -- elem == set \ {elem}
```

## 3.2 ä¸å˜é‡
æ˜¯å¸ƒå°”è¡¨è¾¾å¼
åœ¨æ¨¡å‹æ¯ä¸€æ­¥æ‰§è¡Œç»“æŸåéƒ½ä¼šæ£€æŸ¥

### 3.2.1 Logical Operator
ç”¨æ¥è¡¨ç¤ºæ›´å¤æ‚çš„å…³ç³»

#### \A
ï¼‚é›†åˆä¸­çš„æ¯ä¸€ä¸ªæˆå‘˜ï¼‚
ç©ºé›†çš„\Aä¸ºçœŸ

æ£€æŸ¥setä¸­æ˜¯å¦æ‰€æœ‰çš„æˆå‘˜çš„å€¼éƒ½å°äºmaxï¼š
`AllLessThan(set, max) == \A num \in set: num < max`


#### \E
ï¼‚é›†åˆä¸­è‡³å°‘æœ‰ä¸€ä¸ªæˆå‘˜â€¦â€¦ï¼‚
âš ï¸ ç©ºé›†çš„\Eä¸ºå‡

ä¸‹é¢æ£€æŸ¥ä¸€ä¸ªåºåˆ—ä¸­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæˆå‘˜åœ¨é›†åˆsetä¸­ï¼š
```
SeqOverlapsSet(seq, set) == \E x \in 1..Len(seq): seq[x] \in set

>> SeqOverlapsSet(<<1, 3>>, {2, 3, 4}) 
TRUE
```

#### \Aå’Œ\Eçš„ä¾‹å­

ï¼‚commutativeï¼‚ç®—å­ï¼ŒæŒ‡çš„æ˜¯å‚æ•°çš„æ¬¡åºä¸å½±å“ç»“æœï¼Œä¾‹å¦‚ï¼Œadd(a,b)==add(b,a)

![](media/15604802934058/15605012851479.jpg)


#### => å’Œ <=>

`P => Q`çš„æ„æ€æ˜¯ï¼Œè‹¥Pä¸ºçœŸï¼Œåˆ™Qä¸ºçœŸ
> è¿™ä¸ªå¥½å¥‡æ€ª

`P <=> Q`çš„æ„æ€æ˜¯ï¼ŒPå’ŒQè¦ä¹ˆéƒ½ä¸ºçœŸï¼Œè¦ä¹ˆéƒ½ä¸ºå‡ã€‚
> ç­‰ä»·çš„æ„æ€


```
Xor(A, B) == (~A /\ B) \/ (A /\ ~B) 
OtherXor(A, B) == ~A <=> B 

>> \A A \in BOOLEAN, B \in BOOLEAN: Xor(A, B) = OtherXor(A, B) 
TRUE
```

### 3.2.2 è¡¨è¾¾å¼ä¸­å¯ä»¥ç”¨åˆ°çš„

#### LET-IN
ç”¨æ¥å®šä¹‰è¡¨è¾¾å¼ä¸­ç”¨åˆ°çš„å±€éƒ¨ç®—å­å’Œå®šä¹‰

![](media/15604802934058/15605021253657.jpg)

> å®ƒçš„æ„æ€æ˜¯ï¼Œ`LET`ä¸­å®šä¹‰ï¼Œç»™`IN`ä¸­çš„è¡¨è¾¾å¼ç”¨
> åœ¨LETä¸­å®šä¹‰äº†lastå’Œfirstä¸¤ä¸ªç®—å­ï¼Œç»™åé¢çš„è¡¨è¾¾å¼`<<last>> \o first`ä½¿ç”¨

#### IF-THEN-ELSE
> è¦æ³¨æ„å’Œå‰é¢çš„2.2.4ä¸­çš„ifè¯­å¥çš„åŒºåˆ«ã€‚è¿™ä¸ªæ˜¯è¡¨è¾¾å¼ï¼Œè€Œ`if`åˆ™æ˜¯è¯­å¥ï¼Œä¸ä¸€æ ·çš„


```
Max(x, y) == IF x > y THEN x ELSE y 

>> <<Max(2, 3), Max(3, 2)>> 
<<3, 3>>
```

#### CASE


```
CASE x = 1 -> TRUE   
    [] x = 2 -> TRUE   
    [] x = 3 -> 7   
    [] OTHER -> FALSE
```

#### CHOOSE

`CHOOSE x \in S : P(x)`

è‹¥xæ²¡æœ‰æ‰¾åˆ°åŒ¹é…ï¼ŒTLCä¼šäº§ç”Ÿé”™è¯¯


```
IndexOf(seq, elem) ==   CHOOSE i \in 1..Len(seq): seq[i] = elem 

>> IndexOf(<<8, 3, 1>>, 3) 
2

>> IndexOf(<<8, 3, 1>>, 4) 
Attempted to compute the value of an expression of form CHOOSE x \in S: P, but no element of S satisfied P.
```


```
Max(set) == CHOOSE x \in set: \A y \in set: x >= y 

>> Max(1..10) 
10
```

ä¸‹é¢æ˜¯å®ç°è§£æ–¹ç¨‹$2x + y =  âˆ’ 2 and 3x âˆ’ 2y = 1$

![](media/15604802934058/15605146824151.jpg)

## 3.3 Function å‡½æ•°
å®ƒå…¶å®æ˜¯ä¸€ç§æ˜ å°„ã€‚å®ƒå®šä¹‰äº†é›†åˆåˆ°é›†åˆçš„æ˜ å°„ï¼š
` [x \in set |-> P(x)]`
ä¹Ÿæ”¯æŒè¾“å…¥æ˜¯å¤šä¸ªé›†åˆï¼š
* `[x, y \in set |-> P(x, y)]`
* `[x \in set1, y \in set2 |-> Q(x,y)]`

è°ƒç”¨å‡½æ•°ï¼š`f[bar]`

> structå’Œfunctionçš„å·®åˆ«ã€‚structæ˜¯å€¼åˆ°æŸç§ç±»å‹ï¼Œfunctionæ˜¯é›†åˆåˆ°é›†åˆ

tupleå’Œstructæ˜¯ç‰¹æ®Šçš„å‡½æ•°ï¼š
* tupleçš„åŸŸæ˜¯1ï¼Œ..n
* structçš„åŸŸæ˜¯å­—ç¬¦ä¸²çš„é›†åˆ


```
Flags == {"f1", "f2"} 
(*--algorithm flags 
variables   
    flags = [f \in Flags |-> FALSE]; 
begin   
    with f \in Flags do
        flags[f] := TRUE;   
    end with; 
end algorithm; *)
```

### 3.3.1 å‡½æ•°å’Œç®—å­

å¯ä»¥æŠŠå‡½æ•°ç”¨ä½œç®—å­ï¼Œè‹¥æ²¡æœ‰å‚æ•°ï¼Œä¸‹é¢ä¸¤ç§å†™æ³•éƒ½å¯¹ï¼š

```
Op == [x \in S |-> P(x)] 
Op[x \in S] == P(x)
```
ç®—å­å¯ä»¥æ˜¯ä»»ä½•è¾“å…¥ï¼Œå‡½æ•°å¿…é¡»æ˜¯ç‰¹å®šçš„åŸŸ


```
SumUpTo(n) ==   
    LET F[m \in 0..n] ==     
        IF m = 0 THEN 0     
        ELSE m + F[m-1]   
   IN F[n] 
   
>> SumUpTo(10) 
55
```

ç”¨PTåº“çš„`ReduceSet`æ¥å®ç°ï¼š
```
PT == INSTANCE PT 

SumUpTo(n) ==   
    PT!ReduceSet(LAMBDA x, y: x + y, 0..n, 0) 

>> SumUpTo(10) 
55
```

#### åŸŸDOMAIN

å°±æ˜¯å‡½æ•°çš„è¾“å…¥

è‹¥`func == [x \in set |-> ...]`,åˆ™ `DOMAIN func = set`
`DOMAIN seq = 1..Len(seq)`
`DOMAIN struct`æ˜¯æ‰€æœ‰Keyçš„é›†åˆ

#### @@
è¦å…ˆ`EXTENDS TLC`
`f @@ g`ï¼šmergeä¸¤ä¸ªå‡½æ•°ä¸€ä¸€åŸŸä¸ºfå’Œgçš„åŸŸçš„å¹¶é›†ï¼Œä¸”è‹¥xæ—¢åœ¨fçš„åŸŸå†…åˆåœ¨gçš„åŸŸå†…ï¼Œåˆ™ä¸ºf[x]ï¼Œå¦åˆ™g[x]

```
Merge(f, g) == [   
    x \in (DOMAIN f) \union (DOMAIN g) |->     
        IF x \in DOMAIN f THEN f[x] ELSE g[x]   
   ]
```


```
EXTENDS TLC 
f[x \in 1..2] == "a" 
g[x \in 2..3] == "b" 

>> f @@ g 
<<"a", "a", "b">> 
>> g @@ f 
<<"a", "b", "b">>
```

#### :>
ä¹Ÿè¦å…ˆ`EXTENDS TLC`ã€‚

`a :> b`å°±æ˜¯å‡½æ•°`[x \in {a} |-> b]`çš„ç®€å†™
> åé¢ä¼¼ä¹ä¹Ÿæ²¡æœ‰è§è¿‡

### 3.3.2 å‡½æ•°çš„é›†åˆ [set1 -> set2]

`[set1 -> set2]`æ˜¯æŠŠ`set1`çš„æˆå‘˜æ˜ å°„åˆ°`set2`çš„æ‰€æœ‰å‡½æ•°çš„é›†åˆ
âš ï¸ åŒºåˆ†å‡½æ•°å’Œå‡½æ•°é›†åˆï¼š
âš ï¸ å®ƒå’Œ2.3.1ä¸­çš„[key:set]çš„å·®åˆ«è¦å†è¾©æä¸€ä¸‹

```
>> [s \in {"a", "b"} |-> {1, 2}] 
[a |-> {1, 2}, b |-> {1, 2}] 

>> [{"a", "b"} -> {1, 2}] 
{ [a |-> 1, b |-> 1],      
[a |-> 1, b |-> 2],      
[a |-> 2, b |-> 1],      
[a |-> 2, b |-> 2] }
```

é‡æ„`item \X item \X item \X item`ï¼š
å®šä¹‰`SeqOf(set, count)`ï¼š

```
SeqOf(set, count) == [1..count -> set]

>> SeqOf({"a", "b", "c"}, 2) 
{ <<"a", "a">>, <<"a", "b">>, <<"a", "c">>, <<"b", "a">>, ... }
```

å¦ä¸€ä¸ªä¾‹å­ï¼š

```
Flags == {"f1", "f2"} 
(*--algorithm flags 
variables   
    flags \in [Flags -> BOOLEAN] 
begin
    \* . . .
```
>  âš ï¸ä¹¦ä¸Šè¯´è¿™æ ·æœ‰15ä¸ªçŠ¶æ€ï¼Ÿä½†æ˜æ˜æ˜¯4ä¸ªå•Šï¼{f1,f2}->{t,f}åº”å½“æ˜¯4ä¸ªï¼

è‡³å°‘æœ‰ä¸€ä¸ªflagä¸ºtrueçš„å†™æ³•ï¼š

```
flags \in {config \in [Flags -> BOOLEAN]: \E f \in Flags: config[f]}
```
> âš ï¸ åˆ†æä¸æ¸…è¿™ä¸ªç»“æ„ï¼Œäº¤ç»‡åœ¨ä¸€èµ·äº†ï¼

## 3.4 ä¾‹å­
### 3.4.1  é—®é¢˜æè¿°
èƒŒåŒ…ä¸­æ€ä¹ˆæ”¾ä¸œè¥¿æœ€ä¼˜çš„é—®é¢˜
* èƒŒåŒ…æœ‰å®¹ç§¯N
* æœ‰å‡ ç±»ç‰©å“ï¼Œæ¯ç±»ç‰©å“æœ‰å¤§å°ï¼ˆä½“ç§¯ï¼‰å’Œä»·å€¼
* æ€æ ·é€‰æ‹©ç‰©å“çš„ç»„åˆæ‰èƒ½å¸¦èµ°ä»·å€¼æœ€é«˜

### 3.4.2 åˆå€¼å»ºæ¨¡
> ç»™åˆå€¼å»ºæ¨¡ï¼Œå…¶å®å°±æ˜¯å„ç§æµ‹è¯•çš„åˆå§‹çŠ¶æ€

#### 3.4.2.1 èƒŒåŒ…
èƒŒåŒ…åªæœ‰ä¸€ä¸ªå®¹ç§¯çš„å±æ€§ï¼Œç”¨ä¸€ä¸ªæ•°å­—å°±å¯ä»¥
`Capacity == 7`

#### 3.4.2.2 ç‰©å“ç§ç±»
ç‰©å“çš„ç§ç±»ç”¨ä¸€ä¸ªsetå°±å¯ä»¥ï¼š
`Items == {â€aâ€œ, â€bâ€œ, â€câ€œ}`

#### 3.4.2.3 æ¯ç±»ç‰©å“çš„ä¸ªæ•°ï¼Œä½“ç§¯å’Œä»·å€¼
 æ¯ç±»ç‰©å“çš„å°ºå¯¸å’Œä»·å€¼ï¼Œsizeå’Œvalueå±æ€§ã€‚
 
 
##### 3.4.2.3.1 ç¬¬ä¸€ç§è¡¨ç¤º
ç”¨ä¸€ä¸ªsetæ¥è¡¨ç¤ºï¼Œç”¨åå­—æ¥æ ‡è¯†ä¸åŒçš„ç‰©å“ã€‚
æ¯”å¦‚ï¼Œç”¨ç¡¬ç¼–ç æ–¹å¼ç»™å‡ºä¸€ä¸ªç‰©å“å±æ€§å®šä¹‰ï¼š
```
HardcodedItemSet == {   
    [item |-> â€aâ€œ, size |-> 1, value |-> 1],   
    [item |-> â€bâ€œ, size |-> 2, value |-> 3],   
    [item |-> â€câ€œ, size |-> 3, value |-> 1] 
}
```
è¿™æ ·å†™ï¼Œæ‰¾æŸç§ç‰©å“å°±æ¯”è¾ƒéº»çƒ¦ï¼š

```
ValueOf(item) == (CHOOSE struct \in HardcodedItemSet: struct.item = item).value

>> ValueOf("a")
```
è€Œä¸”ï¼Œè¿˜æ— æ³•ç¡®ä¿æ•°æ®çš„æ­£ç¡®æ€§ï¼Œä¾‹å¦‚ï¼Œè‹¥ä¸¤ç±»ç‰©å“åå­—å†™ç›¸åŒäº†

> æˆ‘çš„ç†è§£æ˜¯ï¼Œåœ¨ç”¨TLAéªŒè¯è®¾è®¡ï¼Œå¦‚æœåœ¨è¿™é‡Œè®¾è®¡ä½¿ç”¨äº†æŸç§æ•°æ®ç»“æ„ï¼Œé‚£ä¹ˆåœ¨çœŸæ­£çš„äº§å“å¼€å‘ä¸­ä¹Ÿåº”ç”¨ç›¸åŒå±æ€§çš„æœºåˆ¶ï¼Œä¾‹å¦‚ï¼Œè¿™é‡Œç”¨äº†å­—å…¸ï¼Œåœ¨ä»£ç ä¸­å°±ä¸åº”ç”¨æ•°ç»„ã€‚

##### 3.4.2.3.2 ç¬¬äºŒç§è¡¨ç¤º
æŠŠç‰©å“çš„å±æ€§ä¿¡æ¯å®ç°ä¸ºå­—å…¸ï¼ˆç»“æ„ï¼‰ï¼Œkeyæ˜¯ç‰©å“çš„åç§°ã€‚

```
HardcodedItemSet == [   
    a |-> [size |-> 1, value |-> 1],   
    b |-> [size |-> 2, value |-> 3],   
    c |-> [size |-> 3, value |-> 1] 
]
```

##### 3.4.2.3.3 æœ€ç»ˆ 

```
ItemParams == [size: 2..4, value: 0..5]

ItemSets == [Items -> ItemParams]
```

> `ItemParams`å®šä¹‰äº†`size`å±æ€§å–2..4çš„å€¼ï¼Œè€Œ`value`å±æ€§å–0..5
> å‚è§2.3.1ï¼Œ[key:value]è¯­æ³•ã€‚

>  `ItemSet`åˆ™æ˜¯å½¢æˆäº†ä¸€ä¸ªç‰©å“ç§ç±»å’Œç‰©å“å±æ€§çš„ç»„åˆå…¨é›†ã€‚çœ‹3.3.2


### 3.4.3 æœ‰æ•ˆçš„ç‰©å“ç»„åˆ
æ”¾åˆ°åŒ…é‡Œçš„ç‰©å“çš„æ¡ä»¶ï¼š
1. æ¯ç±»ç‰©å“ä¸ªæ•°ä¸èƒ½è¶…è¿‡å®ƒæœ‰çš„ä¸ªæ•°
2. æ€»ä½“ç§¯ä¸èƒ½è¶…è¿‡èƒŒåŒ…çš„å®¹ç§¯

#### 3.4.3.1 ç‰©å“é€‰æ‹©æ–¹æ¡ˆçš„è¡¨ç¤º
å°±æ˜¯æ¯ç§ç‰©å“çš„ä¸ªæ•°
å®ƒçš„å½¢å¼æ˜¯`[Items -> Count]`ï¼Œ
* `Items`æ˜¯ç‰©å“çš„åç§°çš„é›†åˆï¼Œ
* `Count`æ˜¯ä¸ªæ•°çš„èŒƒå›´ï¼Œä»¥åå¯ä»¥ä½œä¸ºæ¨¡å—å€¼æä¾›ã€‚

#### 3.4.3.2 é€‰æ‹©çš„ç‰©å“æ€»ä½“ç§¯ä¸èƒ½è¶…è¿‡åŒ…çš„å¤§å°
>  ç”¨äº†`PT!ReduceSet`ï¼Œå’Œå…¶ä»–è¯­è¨€çš„`reduce`ä¸€æ ·çš„


```
KnapsackSize(sack, itemset) ==   
    LET size_for(item) == itemset[item].size * sack[item]
    IN PT!ReduceSet(LAMBDA item, acc: size_for(item) + acc, Items, 0) 
    
ValidKnapsacks(itemset) ==   
    {sack \in [Items -> 0..4]: KnapsackSize(sack, itemset) <= Capacity}
```

![](media/15604802934058/15605646292511.jpg)

### 3.4.4 é€‰æ‹©æœ€ä¼˜è§£
ä»æœ‰æ•ˆçš„ç‰©å“ç»„åˆæ–¹æ¡ˆä¸­é€‰æ‹©ä»·å€¼æœ€é«˜çš„

#### 3.4.4.1 å®ç°1ï¼šæœ‰ç¼ºé™·çš„å®ç°

![](media/15604802934058/15605668777085.jpg)

> `KnapsackValue`è®¡ç®—äº†`sack`ä¸­çš„ç‰©å“çš„æ€»ä»·å€¼ï¼š
> `sack`æ˜¯å½“å‰çš„ç‰©å“ç»„åˆæ–¹æ¡ˆï¼Œå³æ¯ç±»ç‰©å“çš„ä¸ªæ•°
>   `itemset`åˆ™æ˜¯ç‰©å“çš„å±æ€§å®šä¹‰ï¼Œå³æ¯ç±»ç‰©å“çš„å¤§å°å’Œä»·å€¼ã€‚åœ¨è¿™é‡Œç”¨äº†å®ƒçš„ä»·å€¼å±æ€§ä¸€ä¸€`value`ã€‚
> `itemset`æ˜¯å‰é¢çš„`itemsets`ä¸­çš„ä¸€ä¸ªæˆå‘˜

> `BestKnapsack`åˆ™æ˜¯ä»æ‰€æœ‰çš„ç‰©å“ä¸ªæ•°ç»„åˆä¸­é€‰æ‹©åŸºäºç‰©å“å±æ€§å®šä¹‰`itemset` ä¸­é€‰å‡ºä»·å€¼æœ€é«˜çš„é‚£ä¸ªï¼š
> `all`æ˜¯åŸºäº`itemset`ä¸‹æ‰€æœ‰çš„æ»¡è¶³èƒŒåŒ…å®¹ç§¯é™åˆ¶çš„æ‰€æœ‰çš„å¯èƒ½ç»„åˆ
> ç„¶åç”¨`CHOOSE`é€‰æ ·ä»·æ ¼æœ€é«˜çš„é‚£ä¸ª

è¿™ä¸ªç®—æ³•å¯¹å•ä¸ªçš„`itemset`è®¡ç®—æ­£ç¡®ï¼š

```
>> BestKnapsack(HardcodedItemSet) 
[a |-> 1, b |-> 3, c |-> 0] 

>> KnapsackValue([a |-> 1, b |-> 3, c |-> 0], HardcodedItemSet) 
10
```
ä½†å½“ç”¨æ¥ä»ä¸€ç»„`itemset`é‡Œé¢é€‰æ—¶å‡ºé”™äº†ï¼š

```
>> {BestKnapsack(itemset) : itemset \in ItemSets} 
Attempted to compute the value of an expression of form CHOOSE x \in S: P, but no element of S satisfied P.
```
é”™è¯¯å«`no element of S satisfied P`

> ä¹¦ä¸­è®²äº†æ€ä¹ˆåˆ†æå’Œå®šä½é—®é¢˜ï¼šåŠ äº†ä¸€ä¸ªæ–­è¨€ï¼š

![](media/15604802934058/15605726932799.jpg)
>  ç„¶åæ‰§è¡Œæ£€æŸ¥ï¼š

![](media/15604802934058/15605727931908.jpg)

> è¿™é‡Œçš„é”™è¯¯ä¼¼ä¹åœ¨è¿™ä¸ª`KnapsackValue(best, itemset) > KnapsackValue(worse, itemset)`çš„**>**ä¸Šã€‚å¦‚æœæ”¹æˆ`>=`ä¼¼ä¹å°±å¯ä»¥é¿å…è¿™ä¸ªé”™è¯¯
> 
> ä½†ä¹¦ä¸­è¯´ï¼š`CHOOSE `åœ¨é¢ä¸´å¤šä¸ªå¯ä»¥çš„é€‰æ‹©çš„æ—¶å€™æ˜¯**ä»»æ„ï¼ˆarbitrarilyï¼‰**é€‰æ‹©å…¶ä¸­çš„ä¸€ä¸ªï¼Œè¿™ä¸ªåšæ³•æœªå¿…ä¸ä½ çš„æœŸæœ›ä¸€è‡´
> ä»è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œæ ¸å¿ƒå¹¶ä¸æ˜¯å®ç°ï¼Œè€Œæ˜¯æœŸæœ›ï¼Œæ˜¯è§„æ ¼ã€‚ä½œè€…è®¤ä¸ºï¼Œ**ç”±äºå®é™…ä¸Šå°±å¯èƒ½æ‰¾åˆ°å¤šä¸ªå¹³ç­‰çš„æœ€ä¼˜è§£ï¼Œå› æ­¤è½¯ä»¶åº”è¿”å›æ‰€æœ‰çš„ç»“æœè€Œä¸æ˜¯ï¼‚çŒœï¼‚å…¶ä¸­çš„ä¸€ä¸ª**

#### 3.4.4.2 æ‰¾å‡ºæ‰€æœ‰çš„ä»·å€¼æœ€é«˜çš„
æŠŠæ‰€æœ‰çš„åˆ†æ³•éƒ½æ‰¾å‡ºæ¥ã€‚æœ‰ä¸¤ç§åšæ³•ï¼š
##### ç¬¬ä¸€ç§

æ‰¾å‡ºé‚£äº›æ¯”å…¶ä»–çš„ä»·å€¼é«˜çš„ç»„åˆ


![](media/15604802934058/15605817788643.jpg)

> è¿˜æ˜¯ç»™å®šç‰©å“çš„å±æ€§ï¼Œæ‰¾å„ç§ç»„åˆæ–¹æ³•
> `all`è¿˜æ˜¯æ‰€æœ‰æœ‰æ•ˆçš„ç»„æ³•çš„é›†åˆ
> ä¸¤ä¸ªandæ¡ä»¶
> å¾ˆæ‹—å£

##### ç¬¬äºŒä¸ªç®—æ³•
å…ˆé€‰å‡ºä»»ä¸€ä¸ªæœ€å¥½çš„ï¼Œå†æ‰¾å‡ºæ‰€æœ‰å…¶ä»–çš„å’Œå®ƒç›¸ç­‰çš„

![](media/15604802934058/15605845758720.jpg)

> è¿™ä¸ªç®—æ³•çœ‹ä¸Šå»å¾ˆç¬¨æ‹™ï¼Œæ•ˆç‡ä¹Ÿä½ï¼Œä½†æ¯”ä¸Šä¸€ä¸ªå´æ˜¯é«˜å¾—å¤šï¼

##### æ¯”è¾ƒä¸¤ä¸ªç®—æ³•
ä¸¤ä¸ªç®—æ³•çš„ç»“æœå¹¶ä¸ä¸€è‡´ï¼

![](media/15604802934058/15605850216649.jpg)

è°ƒè¯•ï¼Œæ‰¾ä¸€ä¸‹å“ªäº›`itemset`ä¸¤ä¸ªç®—æ³•ä¸ä¸€æ ·ï¼š

```
LET is == CHOOSE is \in ItemSets:   
    BestKnapsacksTwo(is) /= BestKnapsacksOne(is) 
IN <<is, BestKnapsacksOne(is), BestKnapsacksTwo(is)>>
```

â€¦â€¦
> æ²¡çœ‹æ‡‚ğŸ˜º

##### æ”¹æ­£

![](media/15604802934058/15605855783622.jpg)



#### 3.4.5 ä¼˜åŒ–
æœ€åé€‰æ ·`BestKnapsacksTwo`ï¼Œå»æ‰`KnapsackValue`è°ƒç”¨ï¼Œç›´æ¥å†™è¿›å»ï¼Œå¾—åˆ°æœ€åçš„ç‰ˆæœ¬;


![](media/15604802934058/15605857781833.jpg)



